import "nanopb.proto";

message Config {
  message GPIO {
    message Pin {
      enum Direction {
        IN = 0;
        OUT = 1;
      }
      enum Pull {
        OFF = 0;
        UP = 1;
        DOWN = 2;
      }
      enum Edge {
        BOTH = 0;
        RISING = 1;
        FALLING = 2;
      }
      required uint32 number = 1;
      required bool active = 2 [default = true];
      optional Direction direction = 3;
      optional Pull pull = 4 [default = OFF];
      optional Edge trigger = 5;
    }
    repeated Pin pins = 1;
  }
  message I2C {
    enum Speed {
      BAUD_RATE_100KHZ = 100;
      BAUD_RATE_400KHZ = 400;
    }
    required bool enabled = 1;
    optional Speed speed = 2 [default = BAUD_RATE_100KHZ];
  }
  message UART {
    enum Speed {
      BAUD_RATE_115200 = 115200;
    }
    enum Chr {
      _5 = 5;
      _6 = 6;
      _7 = 7;
      _8 = 8;
      _9 = 9;
    }
    enum Parity {
      NONE = 0;
      ODD = 1;
      EVEN = 2;
    }
    enum StopBits {
      _1 = 1;
      _2 = 2;
    }
    required bool enabled = 1;
    required Speed speed = 2 [default = BAUD_RATE_115200];
    required Chr chr = 3 [default = _8];
    required Parity parity = 4 [default = NONE];
    required StopBits stop_bits = 5 [default = _1];
  }
  optional GPIO gpio = 1; // pins are already callbacks
  optional I2C  i2c = 2 [(nanopb).type = FT_CALLBACK];
  optional UART uart = 3 [(nanopb).type = FT_CALLBACK];
  optional bool spi_on = 4 [(nanopb).type = FT_CALLBACK];
}


message Data {
  message GPIO {
    required uint32 mask = 1;
    required uint32 values = 2;
  }
  message I2C {
    message Read {
      required uint32 addr = 1;
      required uint32 size = 2;
    }
    message Write {
      required uint32 addr = 1;
      required bytes buffer = 2;
    }
    repeated Read reads = 1;
    repeated Write writes = 2;
  }
  optional GPIO gpio = 1;
  optional GPIO triggers = 2;
  optional I2C i2c = 3;
  optional bytes uart = 5;
  optional bytes spi = 6;
}

message Transport {
  required uint64 message_length = 1;
}

message DonglePiRequest {
  required uint32 message_nb = 1;
  optional Config config = 2; // optimization constraint: be sure config is decoded *before* the data that can relies it on.
  optional Data data = 3;
}

message DonglePiResponse {
  message Error {
    enum Type {
      CONFIG = 0;
      GPIO = 1;
      UART = 2;
      I2C = 3;
      SPI = 4;
      OTHER = 15;
    }
    required Type type = 1;
    optional string debug_info = 16;
  }
  required uint32 message_nb = 1;
  optional Data data = 2;
  optional Error error = 16;
}
